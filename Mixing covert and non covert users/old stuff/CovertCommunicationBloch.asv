classdef CovertCommunicationBloch

    methods (Static)

        function without_secret_key = without_secret_key_condition_bloch(P0, P1, P2, Q0, Q1, Q2, Q0)
            % Output:
            %   Checks if D(PK \mid P0) >= D(Qk \mid Q0)

            relative_entropy_bob_vect = zeros(2,1);
            relative_entropy_eve_vect = zeros(2,1);
            
            for x2=1:X2_cardinality

                W_Y_X1_0_X2_x2 = W_Y_X1_0_X2(x2,:);
                W_Y_X1_1_X2_x2 = W_Y_X1_1_X2(x2,:);
                W_Z_X1_0_X2_x2 = W_Z_X1_0_X2(x2,:);
                W_Z_X1_1_X2_x2 = W_Z_X1_1_X2(x2,:);

                relative_entropy_P1_P0 = InformationTheory.relative_entropy(W_Y_X1_1_X2_x2, W_Y_X1_0_X2_x2);
                relative_entropy_eve = InformationTheory.relative_entropy(W_Z_X1_0_X2_x2, W_Z_X1_1_X2_x2);

                relative_entropy_bob_vect(x2) = relative_entropy_bob;
                relative_entropy_eve_vect(x2) = relative_entropy_eve;

            end

            difference_relative_entropy_vect = relative_entropy_eve_vect-relative_entropy_bob_vect;
            disp('difference_relative_entropy_vect')
            disp(difference_relative_entropy_vect)
            sum_signs = sign(difference_relative_entropy_vect(1)) + sign(difference_relative_entropy_vect(2)); 
            % if both are positive the sum is 2
            if (ismembertol(sum_signs, 2, 1e-8)) 
                without_secret_key = 1;
            else
                without_secret_key = 0;
            end

        end %end check without secret key condition

        function bool = check_absolute_continuity_bloch(Qk, Q0, DEBUG)
            % Output:
            %   Checks if Qk is absolutely continuous w.r.t Q0 (Qk << Q0)
            %   that is if for a fixed x2, for all y, Qk = 0 if and only if Q0 = 0
            tolerance = 1e-6;
            bool=1;

            for z=1:length(Qk)
                if ( ismembertol(Qk(z), 0, tolerance) &&  Q0(z) > 0)
                    % found one example, we can stop
                    bool = 0;
                    if DEBUG
                        disp('[ERROR-Constraint] Qk is not absolutely continuous with Q0!');
                    end
                    return
                end
            end
        end
        
        function [bool, absolute_continuity_eve, without_secret_key_condition] = check_theorem_conditions_bloch(W_Y_X1_X2, W_Z_X1_X2, DEBUG)
            tolerance = 1e-8;
            bool = 0;
        
            Q0 = W_Z_X1_X2(1,:); %W_Z_X1_0_X2_0 when both users are off

            P1 = W_Y_X1_X2(3,:); %W_Y_X1_1_X2_0 when user 1 is communicating while user 2 is off
            P2 = W_Y_X1_X2(2,:); %W_Y_X1_0_X2_1 when user 2 is communicating while user 1 is off

            Q1 = W_Z_X1_X2(3,:); %W_Z_X1_1_X2_0 when user 1 is communicating while user 2 is off
            Q2 = W_Z_X1_X2(2,:); %W_Z_X1_0_X2_1 when user 2 is communicating while user 1 is off
            %Q12 = W_Z_X1_X2(4,:); %W_Z_X1_1_X2_1 when both users are communicating

            % checking conditions
            absolute_continuity_eve_Q1_Q0 = check_absolute_continuity_bloch(Q1, Q0, DEBUG);
            absolute_continuity_eve_Q2_Q0 = check_absolute_continuity_bloch(Q2, Q0, DEBUG);
            %absolute_continuity_eve_Q12_Q0 = check_absolute_continuity_bloch(Q12, Q0, DEBUG);
            total = 2;
            
            absolute_continuity_eve = absolute_continuity_eve_Q1_Q0 + absolute_continuity_eve_Q2_Q0 ; %+ absolute_continuity_eve_Q12_Q0;
            without_secret_key_condition = without_secret_key_condition_bloch(P1, P2, Q1, Q2, Q0);
            
            if (ismembertol(absolute_continuity_eve, total, tolerance) && ismembertol(without_secret_key_condition, 1, tolerance))
                bool = 1;
            end
            if DEBUG
                disp(['[INFO] absolute_continuity_eve_Q1_Q0 : ', num2str(absolute_continuity_eve_Q1_Q0)]);
                disp(['[INFO] absolute_continuity_eve_Q2_Q0 : ', num2str(absolute_continuity_eve_Q2_Q0)]);
%                 disp(['[INFO] absolute_continuity_eve_Q12_Q0 : ', num2str(absolute_continuity_eve_Q12_Q0)]);

                disp(['[INFO] without_secret_key_condition : ', num2str(without_secret_key_condition)]);
                disp(['[INFO] bool : ', num2str(bool)]);
            end
            
        end
        function users_rates = covert_message_rate(rhos, W_Y_X1_X2, W_Z_X1_X2, DEBUG)
            % Input:
            %   P_T             : a probabilities vector for the time sharing rv
            %   P_X2_mid_T      : conditional probability vector P_{X_2 \mid T}
            %   Epsilon_T       : vector of \epsilon_{t} values 
            %   W_Y_X1_X2       : channel law of the legitimate user W_{Y \mid X_1, X_2}
            %   W_Z_X1_X2       : channel law of the adversary W_{Z \mid X_1, X_2}
            % Output:
            %   The rate of the covert user U1
            
            % We first compute the relative entropy for all X_2 for the legitimate user --------------------------------------------------------
            n_users = 2;
            users_rates = zeros(n_users,1); % 2 users

            P0 = W_Y_X1_X2(1,:); %W_Y_X1_0_X2_0 when both users are off
            Q0 = W_Z_X1_X2(1,:); %W_Z_X1_0_X2_0 when both users are off

            P1 = W_Y_X1_X2(3,:); %W_Y_X1_1_X2_0 when user 1 is communicating while user 2 is off
            P2 = W_Y_X1_X2(2,:); %W_Y_X1_0_X2_1 when user 2 is communicating while user 1 is off

            Q1 = W_Z_X1_X2(3,:); %W_Z_X1_1_X2_0 when user 1 is communicating while user 2 is off
            Q2 = W_Z_X1_X2(2,:); %W_Z_X1_0_X2_1 when user 2 is communicating while user 1 is off
            
            % Grouping them in a matrice
            P = zeros(n_users, 1);
            P(1) = P1;
            P(2) = P2;

            Q = zeros(n_users, 1);
            Q(1) = Q1;
            Q(2) = Q2;

            chi_rho = InformationTheory.chi_2_distance_bloch(Q, Q0);
            
            for k=1:n_users                
                relative_entropy = InformationTheory.relative_entropy(P(k), P0);
                ratio = sqrt(2)/sqrt(chi_rho);
                users_rates(k) = ratio*rhos(k)*relative_entropy;
            end

            if DEBUG
                disp('users_rates');
                disp(users_rates);
            end
        end % end covert_message_rate

    end % end methods
end