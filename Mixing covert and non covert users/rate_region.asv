% seed for reproducibility
seed                            = 1998;
rng(seed);

% for simulation
% \matchal{T} is of cardinality 4, choose it uniform for simplicity
T_cardinality                   = 3;
uniform_P_T                     = 0;
X1_cardinality                  = 2;
X2_cardinality                  = 2;
X1_X2_cardinality               = 4;
Y_cardinality                   = 4;
N_epochs                        = 100000000;
max_epsilon_t                   = 1;
optimize_epsilons_T             = 1;
generate_random_channel_laws    = 0;
% maximum value of P_{X1}(1)
max_P_X1_1                      = 1;
cpt_higher_than_max_P_X1_1      = 0;
% noise probabilities
pw                              = 0.1;
pw_eve                          = 0.15;

% error in the if conditions (1==1.00)
tolerance                       = 1e-6;

% Prints if debug mode
DEBUG                           = 0;
DEBUG_covert                    = 1;
DEBUG_covert_theorem_contraints = 1;

Epsilon_T = max_epsilon_t*rand(T_cardinality,1);

% for fixed epsilon_T
if (ismembertol(optimize_epsilons_T, 0, tolerance))
    disp('[INFO] Running experiment with fixed Epsilon_T')
    Epsilon_T           = max_epsilon_t*rand(T_cardinality,1); %[0.3 0.1 0.2 0.4];
else
    disp('[INFO] Running experiment with different Epsilon_T')
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fix the channel law %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% MAC Channel matrix : We consider the channel Y = (2*X1 + X2 + w) % 4 where all variables are binary => \mathcal{Y} = \{0,1,2,3}
% for each Y and fixed (x1, x2) we have a vector of probabilities [y=0, y=1, y=2, y=3]

P_X2_mid_T = [[1 1 1] ; [0 0 0]];
if (ismembertol(generate_random_channel_laws, 1, tolerance))
%     m=4;
%     n=4;
%     smallest_poba_value_bob = 0.2;
%     smallest_poba_value_eve = 0.2;
    
    % loop while untill constraint on absolute continuity and difference are met  
    W_Y_X1_X2 = transpose(InformationTheory.generate_probability_vector(X1_X2_cardinality,Y_cardinality,1,0,1)); % InformationTheory.generate_random_channel_matrix(m, n, smallest_poba_value_bob);
    W_Z_X1_X2 = transpose(InformationTheory.generate_probability_vector(X1_X2_cardinality,Y_cardinality,1,0,1)); % InformationTheory.generate_random_channel_matrix(m, n, smallest_poba_value_eve);
    verified_conditions = CovertCommunication.check_theorem_conditions(W_Y_X1_X2, W_Z_X1_X2, T_cardinality, Epsilon_T, P_X2_mid_T, X2_cardinality, DEBUG_covert_theorem_contraints);
    while (verified_conditions < 1)
%         smallest_poba_value_bob = 0.1*rand(1,1);
%         smallest_poba_value_eve = 0.1*rand(1,1);
        W_Y_X1_X2 = transpose(InformationTheory.generate_probability_vector(X1_X2_cardinality,Y_cardinality,1,0,1)); %generate_random_channel_matrix
        W_Z_X1_X2 = transpose(InformationTheory.generate_probability_vector(X1_X2_cardinality,Y_cardinality,1,0,1)); %generate_random_channel_matrix
        verified_conditions = CovertCommunication.check_theorem_conditions(W_Y_X1_X2, W_Z_X1_X2, T_cardinality, Epsilon_T, P_X2_mid_T, X2_cardinality, DEBUG_covert_theorem_contraints);
    end
else
    % Binary noise rv follows a bernoulli distribution    
    P_W                 = [1-pw pw]; % [P_W(0) P_W(1)], low probability of noise    
    P_W_eve             = [1-pw_eve pw_eve]; % [P_W_eve(0) P_W_eve(1)], higher probability of noise for the adversary channel

    % Legitimate user channel
    eps=pw;
    W_Y_X1_0_X2_0 = [1-pw-eps/2 pw-eps/2 eps/2 eps/2]; % [y=0, y=1, y=2, y=3]
    W_Y_X1_0_X2_1 = [eps/4 1-pw-eps/2 pw-eps/2 3*eps/4]; % [y=0, y=1, y=2, y=3]
    W_Y_X1_1_X2_0 = [eps/2 eps/2 1-pw-eps/2 pw-eps/2]; % [y=0, y=1, y=2, y=3]
    W_Y_X1_1_X2_1 = [pw-eps/2 3*eps/4 eps/4 1-pw-eps/2]; % [y=0, y=1, y=2, y=3]
    
    W_Y_X1_X2 = zeros(4,4);
    W_Y_X1_X2(1,:) = W_Y_X1_0_X2_0;
    W_Y_X1_X2(2,:) = W_Y_X1_0_X2_1;
    W_Y_X1_X2(3,:) = W_Y_X1_1_X2_0;
    W_Y_X1_X2(4,:) = W_Y_X1_1_X2_1;
    
    % Eve's channel    
    eps=pw_eve;
    W_Z_X1_0_X2_0 = [1-pw_eve-eps/2     pw_eve-eps/2        eps/4               3*eps/4]; % [y=0, y=1, y=2, y=3]
    W_Z_X1_0_X2_1 = [eps/4              1-pw_eve-eps/2      pw_eve-eps/2        3*eps/4]; % [y=0, y=1, y=2, y=3]
    W_Z_X1_1_X2_0 = [3*eps/4            eps/4               1-pw_eve-eps/2      pw_eve-eps/2]; % [y=0, y=1, y=2, y=3]
    W_Z_X1_1_X2_1 = [pw_eve-eps/2       3*eps/4             eps/4               1-pw_eve-eps/2]; % [y=0, y=1, y=2, y=3]
    
    W_Z_X1_X2 = zeros(4,4);
    W_Z_X1_X2(1,:) = W_Z_X1_0_X2_0;
    W_Z_X1_X2(2,:) = W_Z_X1_0_X2_1;
    W_Z_X1_X2(3,:) = W_Z_X1_1_X2_0;
    W_Z_X1_X2(4,:) = W_Z_X1_1_X2_1;

    [verified_conditions, absolute_continuity_bob, absolute_continuity_eve, different_output_distributions_eve, without_secret_key_condition] = CovertCommunication.check_theorem_conditions(W_Y_X1_X2, W_Z_X1_X2, T_cardinality, Epsilon_T, P_X2_mid_T, X2_cardinality, DEBUG_covert_theorem_contraints);
    verified_conditions =1;

    if (verified_conditions < 1)
        disp('[ERROR-Constraint] Absolute continuity is not met! Check bellow which one you need to fix.');
        disp(['[INFO] absolute_continuity_bob : ', num2str(absolute_continuity_bob)]);
        disp(['[INFO] absolute_continuity_eve : ', num2str(absolute_continuity_eve)]);
        disp(['[INFO] different_output_distributions_eve : ', num2str(different_output_distributions_eve)]);
        disp(['[INFO] without_secret_key_condition : ', num2str(without_secret_key_condition)]);
        return
    end

    % Verify if all distributions are valid
    sum_pt = sum(P_T);
    sum_pw = sum(P_W);
    assert(ismembertol(sum_pt, 1, tolerance), 'P_T should sum to 1.');
    assert(ismembertol(sum_pw, 1, tolerance), 'P_W should sum to 1.');
    % ismembertol(a, b, tolerance) compute the difference |a-b| and check if it's \leq to the tolerance. It's used here to avoid problem 1.000 == 1
    
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Rate Region simulation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Covert user rates
r1_vect = zeros(N_epochs,1);

% Non covert user rates
r2_vect = zeros(N_epochs,1);


% iterate over all input distributions.
for epoch = progress(1:N_epochs)
    
    % Generate new P_T
    if (uniform_P_T)
        P_T                 = [0.25 0.25 0.25 0.25]; % uniform P_T
    else
        %P_T                 = [0.25 0.01 0.49 0.25]; 
        P_T                 = InformationTheory.generate_probability_vector(T_cardinality,1,1,0,1);
        %P_T                 = [0 0 1 0]; 
    end

    
    if DEBUG
        disp('P_T is:')
        disp(P_T)
    end
    if (ismembertol(optimize_epsilons_T, 1, tolerance))
    % The epsilon's that normalizes the probability of sending one for the covert user (we choose them summing to one for now but it's not necessary)
        Epsilon_T           = max_epsilon_t*rand(T_cardinality,1); %[0.3 0.1 0.2 0.4];
    end
    % Binary alphabet for the covert user, we define the conditional distribution P_{X_1 \mid T}
    P_X1_0_mid_T        = rand(T_cardinality,1); %[0.4 0.6 0.3 0.9]; % [P_X1_mid_T(0|1) P_X1_mid_T(0|2) P_X1_mid_T(0|3) P_X1_mid_T(0|4)] 
    P_X1_1_mid_T        = 1 - P_X1_0_mid_T; % [P_X1_mid_T(1|1) P_X1_mid_T(1|2) P_X1_mid_T(1|3) P_X1_mid_T(1|4)]
    
    % Binary alphabet for the non covert user, we define the conditional distribution P_{X_1 \mid T}
    P_X2_0_mid_T        = rand(T_cardinality,1); %[0.2 0.2 0.3 0.4]; % [P_X2_mid_T(0|0) P_X2_mid_T(0|1) P_X2_mid_T(0|2) P_X2_mid_T(0|3)]
    P_X2_1_mid_T        = 1 - P_X2_0_mid_T; % [P_X2_mid_T(1|0) P_X2_mid_T(1|1) P_X2_mid_T(1|2) P_X2_mid_T(1|3)]
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Conditional input disbutions P_X1_mid_T and P_X2_mid_T %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    P_X1_mid_T          = zeros(2,T_cardinality);

    for t=1:T_cardinality
        P_X1_mid_T(1,t)     = P_X1_0_mid_T(1); % P_X1_mid_T(0|t)
        P_X1_mid_T(2,t)     = P_X1_1_mid_T(1); % P_X1_mid_T(1|t)
    end
    
    P_X2_mid_T          = zeros(X2_cardinality,T_cardinality);
    for t=1:T_cardinality
        P_X2_mid_T(1,t)     = P_X2_0_mid_T(t); % P_X1_mid_T(0|t)
        P_X2_mid_T(2,t)     = P_X2_1_mid_T(t); % P_X2_mid_T(1|t)
    end

% %     P_X1_mid_T(1,1)     = P_X1_0_mid_T(1); % P_X1_mid_T(0|0)
% %     P_X1_mid_T(1,2)     = P_X1_0_mid_T(2); % P_X1_mid_T(0|1)
% %     P_X1_mid_T(1,3)     = P_X1_0_mid_T(3); % P_X1_mid_T(0|2)
% %     P_X1_mid_T(1,4)     = P_X1_0_mid_T(4); % P_X1_mid_T(0|3)
% %     
% %     P_X1_mid_T(2,1)     = P_X1_1_mid_T(1); % P_X1_mid_T(1|0)
% %     P_X1_mid_T(2,2)     = P_X1_1_mid_T(2); % P_X1_mid_T(1|1)
% %     P_X1_mid_T(2,3)     = P_X1_1_mid_T(3); % P_X1_mid_T(1|2)
% %     P_X1_mid_T(2,4)     = P_X1_1_mid_T(4); % P_X1_mid_T(1|3)
% %     
% %     P_X2_mid_T          = zeros(2,T_cardinality);
% %     
% %     P_X2_mid_T(1,1)     = P_X2_0_mid_T(1); % P_X2_mid_T(0|0)
% %     P_X2_mid_T(1,2)     = P_X2_0_mid_T(2); % P_X2_mid_T(0|1)
% %     P_X2_mid_T(1,3)     = P_X2_0_mid_T(3); % P_X2_mid_T(0|2)
% %     P_X2_mid_T(1,4)     = P_X2_0_mid_T(4); % P_X2_mid_T(0|3)
% %     
% %     P_X2_mid_T(2,1)     = P_X2_1_mid_T(1); % P_X2_mid_T(1|0)
% %     P_X2_mid_T(2,2)     = P_X2_1_mid_T(2); % P_X2_mid_T(1|1)
% %     P_X2_mid_T(2,3)     = P_X2_1_mid_T(3); % P_X2_mid_T(1|2)
% %     P_X2_mid_T(2,4)     = P_X2_1_mid_T(4); % P_X2_mid_T(1|3)
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Marginal distributions P_X1 and P_X2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    P_X1                = zeros(1,X1_cardinality);
    
    for x1=1:X1_cardinality
        avg = 0;
        for t=1:length(P_X2_mid_T)
            avg = avg + P_X1_mid_T(x1,t) * P_T(t);
        end
        P_X1(x1) = avg;
    end

    if (P_X1(1) > max_P_X1_1)
        cpt_higher_than_max_P_X1_1 = cpt_higher_than_max_P_X1_1 +1;
        continue
    end

    if DEBUG
        disp('P_X1 is:')
        disp(P_X1)
    end

    P_X2                = zeros(1,2);
    for i=1:2 % because binary symbols
        avg = 0;
        for j=1:length(P_X2_mid_T)
            avg = avg + P_X2_mid_T(i,j) * P_T(j);
        end
        P_X2(i) = avg;
    end
    
    if DEBUG
        disp('P_X2 is:')
        disp(P_X2)
    end
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Marginal distributions P_Y %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    
    P_X1_X2 = [P_X1(1)*P_X2(1) P_X1(1)*P_X2(2) P_X1(2)*P_X2(1) P_X1(2)*P_X2(2)]; % [P1(1)*P2(1) P1(0)*P2(1) P1(1)*P2(0) P1(1)*P2(1)]
    
    if DEBUG
        disp('P_X1_X2 is:')
        disp(P_X1_X2);
    end

    P_Y = zeros(1,4);
    for i=1:length(P_Y)
        P_Y(i) = dot(P_X1_X2, W_Y_X1_X2(:,i));
    end
    if DEBUG
        disp('P_Y is:')
        disp(P_Y)
        disp('sum P_Y is:')
        disp(sum(P_Y));
        disp('sum P_X1_X2 is:')
        disp(sum(P_X1_X2));
    end
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Rate Region simulation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
       
    if DEBUG
        disp('W_Y_X1_X2 is: ');
        disp(W_Y_X1_X2);
    end
    
    
% % %     % y = 0
% % %     W_0_0_0 = W_Y_X1_X2(1,1);
% % %     W_0_0_1 = W_Y_X1_X2(2,1);
% % %     W_0_1_0 = W_Y_X1_X2(3,1);
% % %     W_0_1_1 = W_Y_X1_X2(4,1);
% % %     % y = 1
% % %     W_1_0_0 = W_Y_X1_X2(1,2);
% % %     W_1_0_1 = W_Y_X1_X2(2,2);
% % %     W_1_1_0 = W_Y_X1_X2(3,2);
% % %     W_1_1_1 = W_Y_X1_X2(4,2);
% % %     % y = 2
% % %     W_2_0_0 = W_Y_X1_X2(1,3);
% % %     W_2_0_1 = W_Y_X1_X2(2,3);
% % %     W_2_1_0 = W_Y_X1_X2(3,3);
% % %     W_2_1_1 = W_Y_X1_X2(4,3);
% % %     % y = 3
% % %     W_3_0_0 = W_Y_X1_X2(1,4);
% % %     W_3_0_1 = W_Y_X1_X2(2,4);
% % %     W_3_1_0 = W_Y_X1_X2(3,4);
% % %     W_3_1_1 = W_Y_X1_X2(4,4);
    
    W_Y_X1_0_X2 = zeros(length(P_X2), length(W_Y_X1_X2));
    W_Y_X1_0_X2(1,:) = W_Y_X1_X2(1,:); % W_Y_X1_0_X2_0
    W_Y_X1_0_X2(2,:) = W_Y_X1_X2(2,:); % W_Y_X1_0_X2_1
    
    if DEBUG
        disp('W_Y_X1_0_X2 is: ');
        disp(W_Y_X1_0_X2);
    end
    
    W_Y_X1_0 = zeros(1, length(P_Y));
    for y=1:length(W_Y_X1_0)
        W_y_X1_0 = 0;
        for x2=1:length(P_X2)
            if DEBUG
                disp('-----------------------------');
                disp('P_X2 is: ');
                disp(P_X2);
                disp('x2 is: ');
                disp(x2);
                disp('y is: ');
                disp(y);
                disp('P_X2(x2) is: ');
                disp(P_X2(x2));
                disp('W_Y_X1_0_X2(x2,y) is: ');
                disp(W_Y_X1_0_X2(x2,y));
            end
            W_y_X1_0 = W_y_X1_0 + P_X2(x2) * W_Y_X1_0_X2(x2,y);
        end
        if (W_y_X1_0 == 0)
            W_y_X1_0 = 1e-3;
        end
        W_Y_X1_0(y) = W_y_X1_0;
    end

    if DEBUG
        disp('W_Y_X1_0 is: ');
        disp(W_Y_X1_0);
    end
    r1 = CovertCommunication.covert_message_rate(P_T, P_X2_mid_T, Epsilon_T, W_Y_X1_X2, W_Z_X1_X2, X2_cardinality, DEBUG);
    r1_vect(epoch) = r1;
    
    W_Y_X1_X2_0 = zeros(length(P_X1), Y_cardinality);
    W_Y_X1_X2_0(1,:) = W_Y_X1_X2(1,:); % W_Y_X1_0_X2_0
    W_Y_X1_X2_0(2,:) = W_Y_X1_X2(3,:); % W_Y_X1_1_X2_0
    
    W_Y_X1_X2_1 = zeros(length(P_X1), Y_cardinality);
    W_Y_X1_X2_1(1,:) = W_Y_X1_X2(2,:); % W_Y_X1_0_X2_1
    W_Y_X1_X2_1(2,:) = W_Y_X1_X2(4,:); % W_Y_X1_1_X2_1

    W_Y_X2 = zeros(X2_cardinality,Y_cardinality);

    W_Y_X2_0 = zeros(1, Y_cardinality);
    W_Y_X2_1 = zeros(1, Y_cardinality);
    for y=1:Y_cardinality
        W_y_X2_0 = 0;
        W_y_X2_1 = 0;
        for x1=1:X1_cardinality
            W_y_X2_0 = W_y_X2_0 + P_X1(x1) * W_Y_X1_X2_0(x2,y);
            W_y_X2_1 = W_y_X2_1 + P_X1(x1) * W_Y_X1_X2_1(x2,y);
        end
        W_Y_X2_0(y) = W_y_X2_0;
        W_Y_X2_1(y) = W_y_X2_1;
    end
    W_Y_X2(1,:) = W_Y_X2_0;
    W_Y_X2(2,:) = W_Y_X2_1;

%     r2 = CovertCommunication.non_covert_rate(P_T, P_X2_mid_T, P_X2, W_Y_X2, Y_cardinality, DEBUG_covert); 
    r2 = CovertCommunication.non_covert_rate(P_T, P_X2_mid_T, W_Y_X1_0, W_Y_X1_0_X2, DEBUG_covert);
    r2_vect(epoch) = r2;
    
    if DEBUG
        disp('For P_T: ');
        disp(P_T);
        disp(['The non covert rate r2 is: ', num2str(r2)]);
        disp(['The covert rate r1 is: ', num2str(r1)]);
    end
end

if length(r2_vect) > 1

    min_r1 = min(r1_vect);
    max_r1 = max(r1_vect);
    disp('--------------------------------------')
    disp(['The minimum covert rate r1 is: ', num2str(min_r1)]);
    disp(['The maximum covert rate r1 is: ', num2str(max_r1)]);
    disp('--------------------------------------')
    min_r2 = min(r2_vect);
    max_r2 = max(r2_vect);
    disp(['The minimum non covert rate r2 is: ', num2str(min_r2)]);
    disp(['The maximum non covert rate r2 is: ', num2str(max_r2)]); 
    disp('--------------------------------------')
    disp(['The number of time P_{X1}(1) >', num2str(max_P_X1_1), ' is: ', num2str(cpt_higher_than_max_P_X1_1), '. Which corresponds to a percentage of: ', num2str(100*cpt_higher_than_max_P_X1_1/N_epochs), '%']);  
    disp('--------------------------------------')


    P = [r1_vect r2_vect];
    [k,av] = convhull(P);

    figure 
    ax1 = nexttile;
    scatter(ax1, P(:,1),P(:,2),'')
    hold on
    plot(ax1, P(k,1),P(k,2))
    title(ax1,'Rate region');
    xlabel(ax1,'Covert user rate');
    ylabel(ax1,'Non-covert user rate');

    figure 
    ax2 = nexttile;
    scatter(ax2, r1_vect, r2_vect,'r');
    title(ax2,'Rate region');
    xlabel(ax2,'Covert user rate');
    ylabel(ax2,'Non-covert user rate');
% 
%     scatter(ax1, r1_vect, r2_vect)
%     hold on;
% %     area(ax1, r1_vect, r2_vect)
% %     hold off;
%     title(ax1,'Rate region');
%     xlabel(ax1,'Covert user rate');
%     ylabel(ax1,'Non-covert user rate');
%     hold on
%     plot(px, py, 'LineWidth', 2);

%     D = ndims(r2_vect) + 1;
%     concatenated_rates_arr = cat(D,r1_vect,r2_vect);
%     [min_rates, ind_min] = min(concatenated_rates_arr,[], D);
%     [max_rates, ind_max] = max(concatenated_rates_arr,[],D);
%     plot(ax1, concatenated_rates_arr(ind_min),min_rates,'o');
%     plot(ax1, concatenated_rates_arr(ind_max),max_rates,'*');
%     plot(ax1, r1_vect, 'b--o')
%     plot(ax1,r2_vect, r1_vect, 'b--o');
%     plot(ax1,r1_vect, r2_vect, 'b--o');

%     disp(['min_rates: ', num2str(min_rates)]);
%     disp(['ind_min: ', num2str(ind_min)]);
%     disp(['max_rates: ', num2str(max_rates)]);
%     disp(['ind_max: ', num2str(ind_max)]);

    %gen xy spans
%     temps=0:.1:100;
%     press = 0:.1:100;
%     [x, y] = meshgrid(temps,press);
%     %generate the binary mask regions
%     r1 = x.^2+y.^2<50;
%     r2 = (x-50).^2+(y-75).^2<50^2;
%     figure(1),imagesc(r1,'XData',temps, 'YData', press , 'AlphaData', r1)
%     hold on
%     imagesc(r2*2,'XData',temps, 'YData', press , 'AlphaData', r2) %r2 scaled to get different color
%     colorbar 
%     plot(temps,press.^2+4)
%     plot(temps+50,(press-10).^3+4)
    

end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Rate Region simulation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% define a simple channel

% verify the constaints (absolute continuity)


% compute the rate


% do a loop on P_T, P_{X2 \mid T}, P_{X1 \mid T} and \epsilon_T