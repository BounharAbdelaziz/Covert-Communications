% seed for reproducibility
seed                            = 1998;
rng(seed);

% for simulation
n_users                         = 2;
X1_cardinality                  = 2;
X2_cardinality                  = 2;
X1_X2_cardinality               = 4;
Y_cardinality                   = 4;
N_epochs                        = 100;
optimize_rhos                   = 1;
generate_random_channel_laws    = 1;
% maximum value of P_{X1}(1)
max_P_X1_1                      = 1;
cpt_higher_than_max_P_X1_1      = 0;
% noise probabilities
pw                              = 0.1;
pw_eve                          = 0.15;

% error in the if conditions (1==1.00)
tolerance                       = 1e-6;

% Prints if debug mode
DEBUG                           = 0;
DEBUG_covert                    = 1;
DEBUG_covert_theorem_contraints = 1;

Epsilon_T = max_epsilon_t*rand(T_cardinality,1);

% for fixed epsilon_T
if (ismembertol(optimize_rhos, 0, tolerance))
    disp('[INFO] Running experiment with fixed rhos')
    rhos           = InformationTheory.generate_probability_vector(n_users,1,1,0,1);
else
    disp('[INFO] Running experiment with different rhos')
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fix the channel law %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% MAC Channel matrix : We consider the channel Y = (2*X1 + X2 + w) % 4 where all variables are binary => \mathcal{Y} = \{0,1,2,3}
% for each Y and fixed (x1, x2) we have a vector of probabilities [y=0, y=1, y=2, y=3]

if (ismembertol(generate_random_channel_laws, 1, tolerance))
    
    W_Y_X1_X2 = transpose(InformationTheory.generate_probability_vector(X1_X2_cardinality,Y_cardinality,1,0,1)); % InformationTheory.generate_random_channel_matrix(m, n, smallest_poba_value_bob);
    W_Z_X1_X2 = transpose(InformationTheory.generate_probability_vector(X1_X2_cardinality,Y_cardinality,1,0,1)); % InformationTheory.generate_random_channel_matrix(m, n, smallest_poba_value_eve);
    verified_conditions = CovertCommunicationBloch.check_theorem_conditions_bloch(W_Y_X1_X2, W_Z_X1_X2, DEBUG_covert_theorem_contraints);
    
    % loop while untill constraint on absolute continuity and difference are met  
    while (verified_conditions < 1)
        W_Y_X1_X2 = transpose(InformationTheory.generate_probability_vector(X1_X2_cardinality,Y_cardinality,1,0,1)); %generate_random_channel_matrix
        W_Z_X1_X2 = transpose(InformationTheory.generate_probability_vector(X1_X2_cardinality,Y_cardinality,1,0,1)); %generate_random_channel_matrix
        verified_conditions = CovertCommunicationBloch.check_theorem_conditions_bloch(W_Y_X1_X2, W_Z_X1_X2, DEBUG_covert_theorem_contraints);
    end
else
    % Binary noise rv follows a bernoulli distribution    
    P_W                 = [1-pw pw]; % [P_W(0) P_W(1)], low probability of noise    
    P_W_eve             = [1-pw_eve pw_eve]; % [P_W_eve(0) P_W_eve(1)], higher probability of noise for the adversary channel

    % Legitimate user channel
    eps=pw;
    W_Y_X1_0_X2_0 = [1-pw-eps/2 pw-eps/2 eps/2 eps/2]; % [y=0, y=1, y=2, y=3]
    W_Y_X1_0_X2_1 = [eps/4 1-pw-eps/2 pw-eps/2 3*eps/4]; % [y=0, y=1, y=2, y=3]
    W_Y_X1_1_X2_0 = [eps/2 eps/2 1-pw-eps/2 pw-eps/2]; % [y=0, y=1, y=2, y=3]
    W_Y_X1_1_X2_1 = [pw-eps/2 3*eps/4 eps/4 1-pw-eps/2]; % [y=0, y=1, y=2, y=3]
    
    W_Y_X1_X2 = zeros(4,4);
    W_Y_X1_X2(1,:) = W_Y_X1_0_X2_0;
    W_Y_X1_X2(2,:) = W_Y_X1_0_X2_1;
    W_Y_X1_X2(3,:) = W_Y_X1_1_X2_0;
    W_Y_X1_X2(4,:) = W_Y_X1_1_X2_1;
    
    % Eve's channel    
    eps=pw_eve;
    W_Z_X1_0_X2_0 = [1-pw_eve-eps/2     pw_eve-eps/2        eps/4               3*eps/4]; % [y=0, y=1, y=2, y=3]
    W_Z_X1_0_X2_1 = [eps/4              1-pw_eve-eps/2      pw_eve-eps/2        3*eps/4]; % [y=0, y=1, y=2, y=3]
    W_Z_X1_1_X2_0 = [3*eps/4            eps/4               1-pw_eve-eps/2      pw_eve-eps/2]; % [y=0, y=1, y=2, y=3]
    W_Z_X1_1_X2_1 = [pw_eve-eps/2       3*eps/4             eps/4               1-pw_eve-eps/2]; % [y=0, y=1, y=2, y=3]
    
    W_Z_X1_X2 = zeros(4,4);
    W_Z_X1_X2(1,:) = W_Z_X1_0_X2_0;
    W_Z_X1_X2(2,:) = W_Z_X1_0_X2_1;
    W_Z_X1_X2(3,:) = W_Z_X1_1_X2_0;
    W_Z_X1_X2(4,:) = W_Z_X1_1_X2_1;

    verified_conditions = CovertCommunicationBloch.check_theorem_conditions_bloch(W_Y_X1_X2, W_Z_X1_X2, DEBUG_covert_theorem_contraints);
    if (verified_conditions < 1)
        disp('[ERROR-Constraint] Absolute continuity is not met! Check bellow which one you need to fix.');
        disp(['[INFO] absolute_continuity_bob : ', num2str(absolute_continuity_bob)]);
        disp(['[INFO] absolute_continuity_eve : ', num2str(absolute_continuity_eve)]);
        disp(['[INFO] different_output_distributions_eve : ', num2str(different_output_distributions_eve)]);
        disp(['[INFO] without_secret_key_condition : ', num2str(without_secret_key_condition)]);
        return
    end

    % Verify if all distributions are valid
    sum_pt = sum(P_T);
    sum_pw = sum(P_W);
    assert(ismembertol(sum_pt, 1, tolerance), 'P_T should sum to 1.');
    assert(ismembertol(sum_pw, 1, tolerance), 'P_W should sum to 1.');
    % ismembertol(a, b, tolerance) compute the difference |a-b| and check if it's \leq to the tolerance. It's used here to avoid problem 1.000 == 1
    
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Rate Region simulation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Covert user rates
rates_vect = zeros(N_epochs,1);


% iterate over all input distributions.
for epoch = progress(1:N_epochs)
    
    if (ismembertol(optimize_rhos, 1, tolerance))
    % The epsilon's that normalizes the probability of sending one for the covert user (we choose them summing to one for now but it's not necessary)
        rhos           = InformationTheory.generate_probability_vector(n_users,1,1,0,1);
    end
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Rate Region simulation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
       
    if DEBUG
        disp('W_Y_X1_X2 is: ');
        disp(W_Y_X1_X2);
    end

    users_rates = CovertCommunicationBloch.covert_message_rate(rhos, W_Y_X1_X2, W_Z_X1_X2, DEBUG);

    if DEBUG
        disp('For P_T: ');
        disp(P_T);
        disp(['The non covert rate r2 is: ', num2str(r2)]);
        disp(['The covert rate r1 is: ', num2str(r1)]);
    end
end

if length(rates_vect) > 1
    r1 = users_rates(1,:);
    r2 = users_rates(2,:);

    min_r1 = min(r1);
    max_r1 = max(r1);

    min_r1 = min(r2);
    max_r1 = max(r2);

    disp('--------------------------------------')
    disp(['The minimum covert rate r1 is: ', num2str(users_rates)]);
    disp(['The maximum covert rate r1 is: ', num2str(users_rates)]);
    disp('--------------------------------------')
    disp(['The minimum covert rate r2 is: ', num2str(users_rates)]);
    disp(['The maximum covert rate r2 is: ', num2str(users_rates)]);
    disp('--------------------------------------')
    disp(['The number of time P_{X1}(1) >', num2str(max_P_X1_1), ' is: ', num2str(cpt_higher_than_max_P_X1_1), '. Which corresponds to a percentage of: ', num2str(100*cpt_higher_than_max_P_X1_1/N_epochs), '%']);  
    disp('--------------------------------------')


    P = [r1_vect r2_vect];
    [k,av] = convhull(P);

    figure 
    ax1 = nexttile;
    scatter(ax1, P(:,1),P(:,2),'')
    hold on
    plot(ax1, P(k,1),P(k,2))
    title(ax1,'Rate region');
    xlabel(ax1,'Covert user rate');
    ylabel(ax1,'Non-covert user rate');

    figure 
    ax2 = nexttile;
    scatter(ax2, r1_vect, r2_vect,'r');
    title(ax2,'Rate region');
    xlabel(ax2,'Covert user rate');
    ylabel(ax2,'Non-covert user rate');
% 
%     scatter(ax1, r1_vect, r2_vect)
%     hold on;
% %     area(ax1, r1_vect, r2_vect)
% %     hold off;
%     title(ax1,'Rate region');
%     xlabel(ax1,'Covert user rate');
%     ylabel(ax1,'Non-covert user rate');
%     hold on
%     plot(px, py, 'LineWidth', 2);

%     D = ndims(r2_vect) + 1;
%     concatenated_rates_arr = cat(D,r1_vect,r2_vect);
%     [min_rates, ind_min] = min(concatenated_rates_arr,[], D);
%     [max_rates, ind_max] = max(concatenated_rates_arr,[],D);
%     plot(ax1, concatenated_rates_arr(ind_min),min_rates,'o');
%     plot(ax1, concatenated_rates_arr(ind_max),max_rates,'*');
%     plot(ax1, r1_vect, 'b--o')
%     plot(ax1,r2_vect, r1_vect, 'b--o');
%     plot(ax1,r1_vect, r2_vect, 'b--o');

%     disp(['min_rates: ', num2str(min_rates)]);
%     disp(['ind_min: ', num2str(ind_min)]);
%     disp(['max_rates: ', num2str(max_rates)]);
%     disp(['ind_max: ', num2str(ind_max)]);

    %gen xy spans
%     temps=0:.1:100;
%     press = 0:.1:100;
%     [x, y] = meshgrid(temps,press);
%     %generate the binary mask regions
%     r1 = x.^2+y.^2<50;
%     r2 = (x-50).^2+(y-75).^2<50^2;
%     figure(1),imagesc(r1,'XData',temps, 'YData', press , 'AlphaData', r1)
%     hold on
%     imagesc(r2*2,'XData',temps, 'YData', press , 'AlphaData', r2) %r2 scaled to get different color
%     colorbar 
%     plot(temps,press.^2+4)
%     plot(temps+50,(press-10).^3+4)
    

end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Rate Region simulation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% define a simple channel

% verify the constaints (absolute continuity)


% compute the rate


% do a loop on P_T, P_{X2 \mid T}, P_{X1 \mid T} and \epsilon_T