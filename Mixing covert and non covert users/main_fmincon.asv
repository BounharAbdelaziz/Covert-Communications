%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Rate Region simulation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Steps to follow:
% - define a simple channel
% - verify the constaints (absolute continuity)
% - compute the rate
% - optimize (P_T, P_{X2 \mid T}, \epsilon_T) with fmincon
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear all;

% seed for reproducibility
seed = 1998;
rng(seed);

% simulation parameters
step_size = 0.1;%0.005;
lb_mu_1 = 0;
ub_mu_1 = 1;
lb_mu_2 = 0;
ub_mu_2 = 1;
total_runs = (1+(ub_mu_1-lb_mu_1)/step_size)*(1+(ub_mu_2-lb_mu_2)/step_size);

% \matchal{T} is of cardinality \leq 4
T_cardinalities               = [2,2];
X2_cardinalities              = [2,2];
sk_budgets                    = [0.55,1];
X1_cardinalities              = 2*ones(length(T_cardinalities)); % always 2.

% ploting parameters
plot_3d                       = 1;
draw_convhull                 = 1;

% Prints if debug mode
DEBUG                           = 0;
DEBUG_covert                    = 0;
DEBUG_covert_theorem_contraints = 0;

% make sure we don't have a missing value
assert(length(T_cardinalities) == length(X2_cardinalities))
assert(length(T_cardinalities) == length(sk_budgets))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Rate Region simulation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% we add 3 because we add manually missing points:
%     (r1=0,r2=0) (r1=0,max r2) (max r1, r2=0)
N = total_runs +3;

% The rates are stored in a matrix, each row is for one experiment
r1_vects = zeros(N, length(T_cardinalities)); % length(T_cardinalities) is the number of experiments
r2_vects = zeros(N, length(T_cardinalities));
rk_vects = zeros(N, length(T_cardinalities));

% optimization options
% InitBarrierParam helps with feasibility ;
% (https://groups.google.com/g/comp.soft-sys.matlab/c/rxR6ErkoKXY?pli=1)
% 'InitBarrierParam', 1e10,
options = optimoptions(@fmincon, 'Algorithm', 'interior-point', 'StepTolerance',1e-15,'FunctionTolerance',1e-15,'OptimalityTolerance',1e-15,'MaxFunctionEvaluations',1e+10, 'MaxIterations', 1e3, 'Display','off');

% For each experiment from the list of comparative experiments.
for experiment=1:length(T_cardinalities)

    % for now only one experiment, generalization to be done after.
    T_cardinality           = T_cardinalities(experiment);
    X2_cardinality          = X2_cardinalities(experiment);
    sk_budget               = sk_budgets(experiment);
    X1_cardinality          = X1_cardinalities(experiment);    
    X1_X2_cardinality       = X1_cardinality*X2_cardinality; % cartesian product
    Y_cardinality           = X1_X2_cardinality;

    guessing_vector_cardinality   = X2_cardinality*T_cardinality + 2*T_cardinality; %(epsilon and P_T have T_cardinality and P_{X2 mid T} has T_cardinality for each x2).
    
    % The optimization is over probabilities so they must be in [0,1]
    lb = zeros(guessing_vector_cardinality,1);
    ub = ones(guessing_vector_cardinality,1);

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fix the channel law %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    if (ismembertol(X2_cardinality, 2, 1e-6))
        % For this channel, the diverence in divergence is always negative.
%         W_Y_X1_X2 = [0.2, 0.3, 0.2, 0.3; 0.1, 0.2, 0.3, 0.4;
%                     0.23,0.46, 0.12, 0.19; 0.33,0.26, 0.22, 0.19];   %% first X2_cardinality rows for x1=0 and latter for  x1=1 
%         W_Z_X1_X2 = [0.3, 0.2, 0.1, 0.4; 0.3, 0.2, 0.15, 0.35;
%                     0.33,0.15, 0.23, 0.29; 0.23,0.26, 0.22, 0.29];  %% first X2_cardinality rows for x1=0 and latter for  x1=1 
%     
        % For this channel, the diverence in divergence is always positive.
        W_Y_X1_X2 = [0.2, 0.3, 0.2, 0.3; 0.2, 0.2, 0.3, 0.3;
                    0.23,0.26, 0.22, 0.29; 0.23,0.26, 0.22, 0.29];   %% first X2_cardinality rows for x1=0 and latter for  x1=1 
        W_Z_X1_X2 = [0.3, 0.2, 0.1, 0.4; 0.3, 0.2, 0.15, 0.35;
                    0.43,0.05, 0.33, 0.19; 0.23,0.16, 0.42, 0.19];  %% first X2_cardinality rows for x1=0 and latter for  x1=1 
    %     
        % For this channel, the diverence in divergence is NOT always positive.
    %     W_Y_X1_X2 = [0.2699, 0.1778, 0.3654, 0.1869; 0.1354, 0.0257, 0.5771, 0.2618;
    %                  0.5998, 0.0983, 0.1839, 0.1180; 0.0186, 0.6658, 0.0725, 0.2431];
    % 
    %     W_Z_X1_X2 = [0.3872, 0.2845, 0.3081, 0.0202; 0.0717, 0.2060, 0.1655, 0.5568;
    %                  0.5419, 0.2992, 0.0587, 0.1002; 0.2741, 0.4258, 0.2249, 0.0752];

        % Extract specific channel laws
        [W_Y_X1_1_X2, W_Y_X1_0_X2, W_Z_X1_1_X2, W_Z_X1_0_X2]    = CovertCommunication.extract_laws(W_Y_X1_X2, W_Z_X1_X2, X2_cardinality,Y_cardinality);
    else
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fix a random channel law %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        % MAC Channel matrix : We consider the channel Y = (2*X1 + X2 + w) % 4 where all variables are binary => \mathcal{Y} = \{0,1,2,3}
        % for each Y and fixed (x1, x2) we have a vector of probabilities [y=0, y=1, y=2, y=3]

        W_Y_X1_X2 = transpose(InformationTheory.generate_probability_vector(Y_cardinality, X1_X2_cardinality,1,0,1));
        W_Z_X1_X2 = transpose(InformationTheory.generate_probability_vector(Y_cardinality, X1_X2_cardinality,1,0,1));
        [W_Y_X1_1_X2, W_Y_X1_0_X2, W_Z_X1_1_X2, W_Z_X1_0_X2] = CovertCommunication.extract_laws(W_Y_X1_X2, W_Z_X1_X2, X2_cardinality,Y_cardinality);
        [verified_conditions, absolute_continuity_bob, absolute_continuity_eve, different_output_distributions_eve] = CovertCommunication.check_theorem_conditions(W_Y_X1_1_X2, W_Y_X1_0_X2, W_Z_X1_1_X2, W_Z_X1_0_X2, X2_cardinality, DEBUG_covert_theorem_contraints);
          
        % loop while untill constraint on absolute continuity and difference are met 
        while (verified_conditions < 1)
            % to get matrices in the size we want, we do a transpose as
            % generate_probability_vector doesn't work if a < b.
            W_Y_X1_X2 = transpose(InformationTheory.generate_probability_vector(Y_cardinality, X1_X2_cardinality,1,0,1));
            W_Z_X1_X2 = transpose(InformationTheory.generate_probability_vector(Y_cardinality, X1_X2_cardinality,1,0,1));
            [W_Y_X1_1_X2, W_Y_X1_0_X2, W_Z_X1_1_X2, W_Z_X1_0_X2] = CovertCommunication.extract_laws(W_Y_X1_X2, W_Z_X1_X2, X2_cardinality,Y_cardinality);
            [verified_conditions, absolute_continuity_bob, absolute_continuity_eve, different_output_distributions_eve] = CovertCommunication.check_theorem_conditions(W_Y_X1_1_X2, W_Y_X1_0_X2, W_Z_X1_1_X2, W_Z_X1_0_X2, X2_cardinality, DEBUG_covert_theorem_contraints);
        end
    end
    


    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Running the simulation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % The loss is \mu_1*r_1 + \mu_2*r_2. We vary \mu_1 and \mu_2 in order
    % to get all points in the boundary. If \mu_1 = 0, we get the maximum
    % rate for r_2 and vice versa. Otherwise, we get the points in between.
    
    index_rates_experiment = 1; % where to store the rates we compute

    for mu_1=progress(lb_mu_1:step_size:ub_mu_1)

        for mu_2=lb_mu_2:step_size:ub_mu_2
            
            % optimization function
            function_to_maximize = @(probas_and_eps) objective_function_fmincon(probas_and_eps, W_Y_X1_1_X2, W_Y_X1_0_X2, W_Z_X1_1_X2, W_Z_X1_0_X2, T_cardinality, X2_cardinality, Y_cardinality, X1_X2_cardinality, mu_1, mu_2, DEBUG_covert);

            % constraints
            nonlcon = @(probas_and_eps) my_rate_constraints(probas_and_eps, sk_budget, W_Y_X1_1_X2, W_Y_X1_0_X2, W_Z_X1_1_X2, W_Z_X1_0_X2, T_cardinality, X2_cardinality, DEBUG_covert);

            % choose a new random point
            probas_and_eps_guess = rand(guessing_vector_cardinality, 1);
            
            % optimize probas_and_eps_guess
            [b_min,fval] = fmincon(function_to_maximize,probas_and_eps_guess,[],[],[],[],lb,ub,nonlcon,options);
            
            % compute the rates with the optimal probas_and_eps_guess for
            % the fixed mu_1 and mu_2.
            [r1, r2, rk] = compute_rates_for_fmincon(b_min, W_Y_X1_1_X2, W_Y_X1_0_X2, W_Z_X1_1_X2, W_Z_X1_0_X2, T_cardinality, X2_cardinality, Y_cardinality, X1_X2_cardinality, sk_budget, DEBUG_covert);

            r1_vects(index_rates_experiment, experiment) = r1;
            r2_vects(index_rates_experiment, experiment) = r2;
            rk_vects(index_rates_experiment, experiment) = rk;

            index_rates_experiment = index_rates_experiment +1;
%             disp(index_rates_experiment)
        end

        % only in debug mode to check if everything is okay with the
        % constraints
        if DEBUG
            disp('b_min')
            disp(b_min)
            [c,ceq] = my_rate_constraints(b_min, sk_budget, W_Y_X1_1_X2, W_Y_X1_0_X2, W_Z_X1_1_X2, W_Z_X1_0_X2, T_cardinality, X2_cardinality, DEBUG_covert);
            disp('c')
            disp(c);
            disp('ceq')
            disp(ceq);
            disp('--------------------------')
            P_X2_mid_T = zeros(X2_cardinality, T_cardinality);
            index = 1;
            for x2=1:X2_cardinality
                for t=1:T_cardinality
                    P_X2_mid_T(x2,t) = b_min(index);
                    index = index + 1;
                end
            end
            P_T = zeros(T_cardinality, 1);
            for t=1:T_cardinality
                P_T(t) = b_min(index);
                index = index + 1;
            end
        
            Epsilon_T = zeros(T_cardinality, 1);
            for t=1:T_cardinality
                Epsilon_T(t) = b_min(index);
                index = index + 1;
            end
            disp('P_X2_mid_T')
            disp(P_X2_mid_T)
            disp('P_T')
            disp(P_T)
            disp('Epsilon_T')
            disp(Epsilon_T)
            disp('sum(P_X2_mid_T)')
            disp(sum(P_X2_mid_T))
            disp('sum(P_T)')
            disp(sum(P_T))
        end
    end

    % adding extrem points that are obviously achievable
    min_r2 = min(r2_vects(:, experiment));
    max_r2 = max(r2_vects(:, experiment));
    min_r1 = min(r1_vects(:, experiment));
    max_r1 = max(r1_vects(:, experiment));
    
    % add (r1=0,r2=0) 
    r1_vects(total_runs+1, experiment)=0;
    r2_vects(total_runs+1, experiment)=0;
    % add (r1=0,max r2) 
    r1_vects(total_runs+2, experiment)=0;
    r2_vects(total_runs+2, experiment)=max_r2;
    % add  (max r1, r2=0)
    r1_vects(total_runs+3, experiment)=max_r1;
    r2_vects(total_runs+3, experiment)=0;
%     step_size = 0.1;
end
           
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Legends %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% To know which size for legends_convhull cell.
sum_non_zero_all = 0;
for experiment=1:length(T_cardinalities)
    check_sum = r1_vects(N, experiment) + r2_vects(N-1, experiment); % max_r1 + max_r2
    if (check_sum >0)
        sum_non_zero_all = sum_non_zero_all + 1;
    end
end
% for legends
legends = cell(length(T_cardinalities), 1);
legends_convhull = cell(sum_non_zero_all+2, 1);

for experiment=1:length(T_cardinalities)
    legends(experiment) = {['X2 cardinality: ', num2str(X2_cardinalities(experiment)), ' // T cardinality: ', num2str(T_cardinalities(experiment)), ' // Secret-Key budget: ',  num2str(sk_budgets(experiment))]};
end

% we need to go through all of them but the indexes should be \leq
% sum_non_zero_all which is < length(T_cardinalities).
index_ = 1;
for experiment=1:length(T_cardinalities)
    check_sum = r1_vects(N, experiment) + r2_vects(N-1, experiment); % max_r1 + max_r2
    if (check_sum >0)
        legends_convhull(index_) = {['X2 cardinality: ', num2str(X2_cardinalities(experiment)), ' // T cardinality: ', num2str(T_cardinalities(experiment)), ' // Secret-Key budget: ',  num2str(sk_budgets(experiment))]};
        % for the delimiter of the square regions
        legends_convhull(index_+1) = {['Square region delimiter for ', 'X2 cardinality: ', num2str(X2_cardinalities(experiment)), ' // T cardinality: ', num2str(T_cardinalities(experiment)), ' // Secret-Key budget: ',  num2str(sk_budgets(experiment))]};
        index_ = index_ + 2; % add 2 instead of 1 because we have two legends for each one
    end
end

title_plot = ['Rate region [seed=', num2str(seed), ']'];
x_title = 'Covert user square-root rate';
y_title = 'Non-Covert user rate';
z_title = 'Secret-Key square-root rate';

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Plots %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

positions = zeros(length(T_cardinalities),1);
for experiment=1:length(T_cardinalities)

    % fix the precision
    digits(2);
    maxval = max(vpa(r2_vects(1:total_runs, experiment)));
    disp(vpa(maxval))

    % find the position of the last one in the line of maximum non covert rate
    position = find(vpa(r2_vects(1:total_runs,experiment))==vpa(maxval),1,'last');    
    positions(experiment,1) = position;
end
disp(positions)

% 3D plot of the region (secret key rate, covert rate, non-covert rate)
if (plot_3d)
    figure 
    ax1 = nexttile;
    for experiment=1:length(T_cardinalities)
        scatter3(ax1, r1_vects(:, experiment), r2_vects(:, experiment), rk_vects(:, experiment));
        hold on
    end
    title(ax1,title_plot);
    xlabel(ax1,x_title);
    ylabel(ax1,y_title);
    zlabel(ax1,z_title);
    legend(legends);
end

% covert rate vs non-covert rate
ax2 = nexttile;
for experiment=1:length(T_cardinalities)
    scatter(ax2, r1_vects(:, experiment), r2_vects(:, experiment));
    hold on
end
title(ax2, title_plot);
xlabel(ax2,x_title);
ylabel(ax2,y_title);
legend(legends);


% secret key rate vs covert rate
ax3 = nexttile;
for experiment=1:length(T_cardinalities)
    scatter(ax3, rk_vects(:, experiment), r1_vects(:, experiment));
    hold on
end
title(ax3, title_plot);
xlabel(ax3,z_title);
ylabel(ax3,x_title);
legend(legends);

% secret key rate vs non-covert rate
ax4 = nexttile;
for experiment=1:length(T_cardinalities)
    scatter(ax4, rk_vects(:, experiment), r2_vects(:, experiment));
    hold on
end
title(ax4, title_plot);
xlabel(ax4,z_title);
ylabel(ax4,y_title);
legend(legends);

% convhull of the rate region (covert and non-covert rates)
if draw_convhull
    figure 
    ax5 = nexttile;
    hold on
    for experiment=1:length(T_cardinalities)
        % if all are zeros then the max is zero, so the convexhull doesn't
        % exist
        check_sum = r1_vects(N, experiment) + r2_vects(N-1, experiment); % max_r1 + max_r2
        if (check_sum >0)
            P_i = [r1_vects(:, experiment) , r2_vects(:, experiment)];
            [k_i,av_i] = convhull(P_i);
            plot(ax5, P_i(k_i,1),P_i(k_i,2))
        else
            disp(['[INFO] Experiment ', num2str(experiment), ' has only one point (0,0,0). No convex hull can be obtained!']);
            continue
        end
        hold on        

        r1_star = r1_vects(positions(experiment),experiment);
        r2_star = r2_vects(positions(experiment),experiment);

        x2 = r1_star;
        y2 = linspace(0,r2_star,100);
        if (ismembertol(experiment, 1, 1e-10))
            plot(x2*ones(size(y2)),y2, '--black');
        else
            plot(x2*ones(size(y2)),y2, '--red');
        end
        hold on
    end
    title(ax5, title_plot);
    xlabel(ax5,x_title);
    ylabel(ax5,y_title);
    legend(legends_convhull);
end